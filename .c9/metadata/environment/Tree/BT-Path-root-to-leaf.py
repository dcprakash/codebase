{"filter":false,"title":"BT-Path-root-to-leaf.py","tooltip":"/Tree/BT-Path-root-to-leaf.py","undoManager":{"mark":7,"position":7,"stack":[[{"start":{"row":1,"column":0},"end":{"row":1,"column":23},"action":"remove","lines":["Your module description"],"id":2},{"start":{"row":1,"column":0},"end":{"row":1,"column":57},"action":"insert","lines":["https://leetcode.com/problems/binary-tree-paths/solution/"]}],[{"start":{"row":3,"column":0},"end":{"row":4,"column":0},"action":"insert","lines":["",""],"id":3}],[{"start":{"row":4,"column":0},"end":{"row":32,"column":8},"action":"insert","lines":["# Definition for a binary tree node.","# class TreeNode:","#     def __init__(self, val=0, left=None, right=None):","#         self.val = val","#         self.left = left","#         self.right = right","class Solution:","    def binaryTreePaths(self, root: TreeNode) -> List[str]:","        self.res=[]","        ","        def btPath(node,path):","            if not node:","                return []","            ","            path+=str(node.val)","            ","            if not node.left and not node.right:","                self.res.append(path)","            else:","                path+=\"->\"","                btPath(node.left,path)","                btPath(node.right,path)","                ","            return self.res","        ","        ","        btPath(root,'')","        return self.res","        "],"id":4}],[{"start":{"row":5,"column":0},"end":{"row":5,"column":2},"action":"remove","lines":["# "],"id":5},{"start":{"row":6,"column":0},"end":{"row":6,"column":2},"action":"remove","lines":["# "]},{"start":{"row":7,"column":0},"end":{"row":7,"column":2},"action":"remove","lines":["# "]},{"start":{"row":8,"column":0},"end":{"row":8,"column":2},"action":"remove","lines":["# "]}],[{"start":{"row":4,"column":0},"end":{"row":31,"column":23},"action":"remove","lines":["# Definition for a binary tree node.","class TreeNode:","    def __init__(self, val=0, left=None, right=None):","        self.val = val","        self.left = left","#         self.right = right","class Solution:","    def binaryTreePaths(self, root: TreeNode) -> List[str]:","        self.res=[]","        ","        def btPath(node,path):","            if not node:","                return []","            ","            path+=str(node.val)","            ","            if not node.left and not node.right:","                self.res.append(path)","            else:","                path+=\"->\"","                btPath(node.left,path)","                btPath(node.right,path)","                ","            return self.res","        ","        ","        btPath(root,'')","        return self.res"],"id":7}],[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["",""],"id":8},{"start":{"row":3,"column":0},"end":{"row":4,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":3,"column":0},"end":{"row":30,"column":23},"action":"insert","lines":["# Definition for a binary tree node.","class TreeNode:","    def __init__(self, val=0, left=None, right=None):","        self.val = val","        self.left = left","#         self.right = right","class Solution:","    def binaryTreePaths(self, root: TreeNode) -> List[str]:","        self.res=[]","        ","        def btPath(node,path):","            if not node:","                return []","            ","            path+=str(node.val)","            ","            if not node.left and not node.right:","                self.res.append(path)","            else:","                path+=\"->\"","                btPath(node.left,path)","                btPath(node.right,path)","                ","            return self.res","        ","        ","        btPath(root,'')","        return self.res"],"id":9}],[{"start":{"row":32,"column":0},"end":{"row":75,"column":0},"action":"insert","lines":["\"\"\"","Your module description","\"\"\"","","# Recursive Python program for level ","# order traversal of Binary Tree","","# A node structure","class Node:","","\t# A utility function to create a new node","\tdef __init__(self, key):","\t\tself.data = key ","\t\tself.left = None","\t\tself.right = None","","","import math","def pathToLeaf(root, path):","\tglobal res","\tif not root:","\t\treturn []","\telse:","\t\tpath+=str(root.data)","\t\tif not root.left and not root.right:","\t\t\tres.append(path)","\t\telse:","\t\t\tpath+='->'","\t\t\tpathToLeaf(root.left, path)","\t\t\tpathToLeaf(root.right, path)","\treturn res","        ","        ","","# Driver program to test above function","root = Node(1)","root.left = Node(2)","root.right = Node(3)","root.left.left = Node(4)","root.left.right = Node(5)","root.left.left.left = Node(6)","res=[]","print(pathToLeaf(root, ''))",""],"id":10}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":52,"column":13},"end":{"row":52,"column":13},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1608958348035,"hash":"2b4d60470e3b4ed9aef9bef95149c5b9eff95455"}